<!DOCTYPE html>
<html lang="pl" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Jak jest zbudowany system plik贸w FAT | Kyriet&#39;S Blog </title>

<link rel="stylesheet" href="/css/main.css?v1" id="main-stylesheet">
<link rel="prefetch" href="/css/highlight-light.css?v1" id="highlight-light-stylesheet">


<link rel="stylesheet" href="/css/dark.css?v1" id="dark-stylesheet">
<link rel="stylesheet" href="/css/highlight-dark.css?v1" id="highlight-dark-stylesheet">



</head>
<body>
  <header>
    

  <nav>
    <div id="navigation">
      <a href="/">Home</a>
      <a href="/projects/">Projekty</a>
  
  <span id="toggle-theme-button" title="Toggle light/dark theme"></span>
    </div>
    <span id="site-title">Kyriet&#39;S Blog </span>
  </nav>


  </header>
  <main>
    
  <h1>Jak jest zbudowany system plik贸w FAT</h1>

   
  <time datetime="2020-05-02" style="display: none">2020-05-02</time>

  <p>W tym wpisie opisz podstawowe zasady dziaania systemu plik贸w z rodziny FAT. Jeli jeste ciekawy co si dzieje &ldquo;pod mask&rdquo;, gdy dodajesz lub usuwasz plik na noniku danych z systemem plik贸w FAT, to zachcam do lektury tego wpisu. Na przykadach i w praktyce poka偶 jakie zmiany zachodz na dysku podczas manipulacji plikami.</p>
<h2 id="z-tego-wpisu-dowiesz-si">Z tego wpisu dowiesz si</h2>
<ul>
<li>Jakie informacje mo偶na znale藕 w <em>Boot Sector</em></li>
<li>Czym jest tablica alokacji (FAT)</li>
<li>Jak reprezentowany jest plik na dysku z systemem FAT</li>
<li>Jak przywr贸ci plik po usuniciu go z dysku z systemem FAT</li>
</ul>
<h2 id="czym-jest-system-plik贸w">Czym jest system plik贸w</h2>
<p><em>System plik贸w</em> jest to metoda przechowywania i zarzdzania danymi na noniku pamici. Najmniejsz porcj danych u偶ytkownika w systemie plik贸w najczciej stanowi plik. Do opisania budowy FAT potrzebne nam bd bardziej szczeg贸owe pojcia: <em>bajt</em>, <em>sektor</em> i <em>klaster</em>. Definicja ta nie jest szczeg贸lnie istotna i przydatna w 偶yciu. Jeli potrzebujesz to wiedzie do kolokwium, to zajrzyj do <a href="https://pl.wikipedia.org/wiki/System_plik%C3%B3w">Wikipedii</a>.</p>
<p>Po przeczytaniu tego wpisu <em>wyczujesz</em> czym jest system plik贸w i bdziesz si czu pewnie, aby opowiedzie co taki system robi.</p>
<h2 id="budowa-fat">Budowa FAT</h2>
<p>Zacznijmy od pokazania jak taki system plik贸w wyglda. Wszystkie czynnoci tutaj przedstawione wykonuj na komputerze z systemem Linux Mint.</p>
<h3 id="utworzenie-czystego-systemu-plik贸w-fat">Utworzenie czystego systemu plik贸w FAT</h3>
<p>Bdziemy potrzebowali urzdzenia do test贸w. Takiego, na kt贸rym bdziemy mogli wykonywa normalne operacje na plikach (utw贸rz, kopiuj, usu). Niezbdna jest r贸wnie偶 mo偶liwo niskopoziomowego podgldu jak dane s zapisane na noniku (bajt po bajcie).</p>
<p>Na szczcie nie bdziemy u偶ywa fizycznego urzdzenia. Stworzymy plik, kt贸ry nastpnie zamontujemy w systemie jako wirtualny &ldquo;nonik danych&rdquo;. Mo偶na sobie to zestawi z analogi do fizycznego pendrive&rsquo;a. Plik to nasz pendrive, a montowanie pliku w systemie, to po prostu wpicie pendriva do komputera (co jak plik z formatem <em>.iso</em>).</p>
<p>Najpierw utw贸rzmy pusty plik o rozmiarze, powiedzmy 100kB. Rozmiar pliku w tym przypadku bdzie oznacza pojemno naszego wirtualnego urzdzenia. +
<em>Uwaga</em>: plikowi nie mo偶na tak po prostu nada rozmiaru. Trzeba go czym wypeni. Tworz wic plik o nazwie <code>fat.img</code> i wypeniam go bajtami o wartoci zero (nie myli z wypenianiem pliku znakami cyfry &lsquo;0&rsquo;).</p>
<pre tabindex="0"><code>dd if=/dev/zero of=fat.img bs=1024 count=100
</code></pre><p>Utworzylimy w ten spos贸b plik o rozmiarze 100kB. Dane tego pliku skadaj si z samych zer. Jest to plik binarny, wic wywietlanie jego zawartoci programami typu <code>less</code> czy <code>cat</code> nie jest dobrym pomysem.</p>
<p>Zobaczmy jak wyglda:</p>
<pre tabindex="0"><code>$ hexdump -C fat.img

00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00019000
</code></pre><p>Wida, 偶e plik jest wypeniony zerami. Program hexdump inteligentnie pokazuje tylko pierwsze 16 bajt贸w, po kt贸rych wstawia znak <code>*</code> oznaczajcy, 偶e ta sekwencja si powtarza a偶 do offsetu <code>00019000</code>, czyli do samego koca pliku (19000~16~ = 102400~10~).</p>
<p>Stw贸rzmy w kocu system plik贸w w naszym pliku.</p>
<pre tabindex="0"><code>$ mkfs.msods fat.img

mkfs.fat 4.1 (2017-01-24)
</code></pre><p>Dlaczego u偶ywam tutaj prehistorycznego FAT12? Poniewa偶 jest najprostszy w budowie i pozwoli w prosty spos贸b pokaza omawiane zagadnienia. P贸藕niejsza analiza, np. FAT32 bdzie o wiele atwiejsza znajc ju偶 podstawy.</p>
<p>Zerknijmy teraz jak wyglda nasz plik w rodku.</p>
<pre tabindex="0"><code>$ hexdump -C fat.img
00000000  eb 3c 90 6d 6b 66 73 2e  66 61 74 00 02 04 01 00  |.&lt;.mkfs.fat.....|
00000010  02 00 02 c8 00 f8 01 00  20 00 40 00 00 00 00 00  |........ .@.....|
00000020  00 00 00 00 80 00 29 9c  38 71 69 4e 4f 20 4e 41  |......).8qiNO NA|
00000030  4d 45 20 20 20 20 46 41  54 31 32 20 20 20 0e 1f  |ME    FAT12   ..|
00000040  be 5b 7c ac 22 c0 74 0b  56 b4 0e bb 07 00 cd 10  |.[|.&#34;.t.V.......|
00000050  5e eb f0 32 e4 cd 16 cd  19 eb fe 54 68 69 73 20  |^..2.......This |
00000060  69 73 20 6e 6f 74 20 61  20 62 6f 6f 74 61 62 6c  |is not a bootabl|
00000070  65 20 64 69 73 6b 2e 20  20 50 6c 65 61 73 65 20  |e disk.  Please |
00000080  69 6e 73 65 72 74 20 61  20 62 6f 6f 74 61 62 6c  |insert a bootabl|
00000090  65 20 66 6c 6f 70 70 79  20 61 6e 64 0d 0a 70 72  |e floppy and..pr|
000000a0  65 73 73 20 61 6e 79 20  6b 65 79 20 74 6f 20 74  |ess any key to t|
000000b0  72 79 20 61 67 61 69 6e  20 2e 2e 2e 20 0d 0a 00  |ry again ... ...|
000000c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|
00000200  f8 ff ff 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000210  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000400  f8 ff ff 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000410  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00019000
</code></pre><p>Otrzymalimy pusty system plik贸w na naszym urzdzeniu. Gdybymy przy tworzeniu systemu plik贸w zamiast pliku <code>fat.img</code> podali cie偶k do zamontowanego pendrive&rsquo;a, to bymy go w ten spos贸b sformatowali i ustawili na nim system plik贸w FAT12.</p>
<h3 id="budowa-boot-sectora-w-fat12">Budowa Boot Sectora w FAT12</h3>
<p>Pierwsze 512 bajt贸w, a wic do offsetu <code>000001f0</code> zajmuje tzw. <em>Boot sector</em> naszego urzdzenia. Znajduj si tam szczeg贸owe informacje o u偶ywanym systemie plik贸w na urzdzeniu. Boot sector w FAT zawsze koczy si sekwencj <code>55 aa</code>.</p>
<p>Po peny opis co oznacza kt贸ry bajt w tym sektorze mo偶esz odwiedzi <a href="https://www.win.tue.nl/~aeb/linux/fs/fat/fat-1.html#ss1.2">t stron</a>.</p>
<p>Ja wypisz kilka ciekawych i najwa偶niejszych wartoci.</p>
<table>
<thead>
<tr>
<th>Nr bajtu</th>
<th>Opis</th>
</tr>
</thead>
<tbody>
<tr>
<td>11-12</td>
<td>Liczba <em>bajt贸w</em> na jeden <em>sektor</em>. Dozwolone wartoci: 512, 1024, 2048, 3096.</td>
</tr>
<tr>
<td>13</td>
<td>Liczba <em>sektor贸w</em> na jeden <em>klaster</em>. Dozwolone wartoci: 1, 2, 4, 8, 16, 32, 64, 128</td>
</tr>
<tr>
<td>16</td>
<td>Liczba kopii <em>FAT (tablicy alokacji)</em></td>
</tr>
<tr>
<td>22-23</td>
<td>Liczba sektor贸w na jedn tablic alokacji</td>
</tr>
<tr>
<td>510-511</td>
<td>Sygnatura <code>55 aa</code></td>
</tr>
</tbody>
</table>
<p>Zerknijmy jeszcze raz na <em>Boot Sector</em>, tym razem dla uatwienia z offsetem dziesitnym i spr贸bujmy odczyta z niego wartoci posugujc si tabel powy偶ej.</p>
<pre tabindex="0"><code>$ od -Ad -tx1z fat.img
0000000 eb 3c 90 6d 6b 66 73 2e 66 61 74 00 02 04 01 00  &gt;.&lt;.mkfs.fat.....&lt;
0000016 02 00 02 c8 00 f8 01 00 20 00 40 00 00 00 00 00  &gt;........ .@.....&lt;
0000032 00 00 00 00 80 00 29 9c 38 71 69 4e 4f 20 4e 41  &gt;......).8qiNO NA&lt;
0000048 4d 45 20 20 20 20 46 41 54 31 32 20 20 20 0e 1f  &gt;ME    FAT12   ..&lt;
0000064 be 5b 7c ac 22 c0 74 0b 56 b4 0e bb 07 00 cd 10  &gt;.[|.&#34;.t.V.......&lt;
0000080 5e eb f0 32 e4 cd 16 cd 19 eb fe 54 68 69 73 20  &gt;^..2.......This &lt;
0000096 69 73 20 6e 6f 74 20 61 20 62 6f 6f 74 61 62 6c  &gt;is not a bootabl&lt;
0000112 65 20 64 69 73 6b 2e 20 20 50 6c 65 61 73 65 20  &gt;e disk.  Please &lt;
0000128 69 6e 73 65 72 74 20 61 20 62 6f 6f 74 61 62 6c  &gt;insert a bootabl&lt;
0000144 65 20 66 6c 6f 70 70 79 20 61 6e 64 0d 0a 70 72  &gt;e floppy and..pr&lt;
0000160 65 73 73 20 61 6e 79 20 6b 65 79 20 74 6f 20 74  &gt;ess any key to t&lt;
0000176 72 79 20 61 67 61 69 6e 20 2e 2e 2e 20 0d 0a 00  &gt;ry again ... ...&lt;
0000192 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
0000496 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa  &gt;..............U.&lt;
0000512 f8 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
0000528 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
0001024 f8 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
0001040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
0102400
</code></pre><p>Bajty liczymy od zera, wic bajt numer 1 ma warto <code>3c</code>, a bajt numer 16 to <code>02</code> itd.</p>
<p>Spr贸buj samodzielnie odczyta wartoci z Boot Sectora. Odpowiedzi zamieszczam w tabeli poni偶ej.</p>
<table>
<thead>
<tr>
<th>Pole</th>
<th>raw</th>
<th>hex</th>
<th>dec</th>
</tr>
</thead>
<tbody>
<tr>
<td>Liczba bajt贸w na sektor</td>
<td><code>00 02</code></td>
<td><code>0200</code></td>
<td>512</td>
</tr>
<tr>
<td>Liczba sektor贸w na klaster</td>
<td><code>04</code></td>
<td><code>04</code></td>
<td>4</td>
</tr>
<tr>
<td>Liczba kopii FAT</td>
<td><code>02</code></td>
<td><code>02</code></td>
<td>2</td>
</tr>
<tr>
<td>Liczba sektor贸w na FAT</td>
<td><code>01 00</code></td>
<td><code>0001</code></td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Mimo tego, 偶e Boot Sector mamy przedstawiony w postaci cigu bajt贸w zapisanych szesnastkowo, musz rozr贸偶nia tutaj warto odczytan (raw) od wartoci liczbowej, kt贸r reprezentuje ten zapis (hex). Warto uzyskamy czytajc bajty w odwrotnej kolejnoci. Jeli nie rozumiesz dlaczego, przeczytaj o formie zapisu <a href="https://pl.wikipedia.org/wiki/Kolejno%C5%9B%C4%87_bajt%C3%B3w">Little Endian</a>.</p>
<p>Z opis贸w z tabel ju偶 si pewnie domylasz jaki stosunek do siebie maj <em>bajty</em>, <em>sektory</em> i <em>klastry</em>.</p>
<p><em>Sektor</em> to zbi贸r <em>bajt贸w</em> o staym rozmiarze.
<em>Klaster</em> to zbi贸r <em>sektor贸w</em> o staym rozmiarze.</p>
<p>Mamy informacj, 偶e tablica alokacji FAT <em>(File Allocation Table)</em> skada si z jednego sektora, a wic z 512 bajt贸w. Wiemy r贸wnie偶, 偶e nasz system plik贸w przechowuje 2 kopie tablicy alokacji (jest to pewna forma zabezpieczenia). Sprawd藕my, czy to co odczytalimy z <em>Boot Sectora</em> si zgadza.</p>
<p>Dokadnie od offsetu 512 zaczyna si pierwsza tablica alokacji FAT, kt贸ra koczy si 512 bajt贸w dalej. Nastpnie zaczyna si identyczna kopia FAT. S tam ju偶 wpisane jakie wartoci. Om贸wimy je za moment.</p>
<h3 id="budowa-tablicy-alokacji-fat">Budowa tablicy alokacji FAT</h3>
<p>Tablica alokacji jest tak map po pamici. Jeli mamy jaki du偶y plik, kt贸ry zajmuje kilka sektor贸w, tablica alokacji powie nam kt贸re kolejne sektory powinnimy odczytywa, aby otrzyma cay plik.</p>
<p>W FAT12 jeden klaster jest kodowany na 12 bitach, a wic jest to 1,5 bajta. Powoduje to troch komplikacji przy pr贸bie rcznego odczytywania wartoci z postaci szesnastkowej, kt贸r my mamy. Dla FAT16 i FAT32 jest to du偶o prostsze.</p>
<p>Odczytajmy zawarto tablicy alokacji, bo wida, 偶e ju偶 co si tam w niej znajduje. Zaczynamy od offsetu 512. Algorytm jest nastpujcy:</p>
<ul>
<li>Wypisz bajty z tablicy alokacji. Zera z koca mo偶emy pomin.</li>
</ul>
<pre tabindex="0"><code>f8 ff ff
</code></pre><ul>
<li>czymy bajty w tr贸jki od lewej do prawej (w naszym przypadku mamy ju偶 tr贸jk, wic nic nie robimy).</li>
</ul>
<pre tabindex="0"><code>ff ff f8
</code></pre><ul>
<li>Przepisujemy wszystkie <em>bajty</em> w tr贸jkach, w odwrotnej kolejnoci
(Taki zapis: <code>ff ff 8f</code> <em>nie</em> jest poprawnym odwr贸ceniem bajt贸w).</li>
</ul>
<pre tabindex="0"><code>ff ff f8
</code></pre><ul>
<li>Wybrane tr贸jki dzielimy na dwie r贸wne czci.</li>
</ul>
<pre tabindex="0"><code>fff ff8
</code></pre><ul>
<li>Ka偶d z par odczytujemy w odwr贸conej kolejnoci. Otrzymalimy tablic alokacji w postaci szesnastkowej.</li>
</ul>
<pre tabindex="0"><code>ff8 fff
[0] [1] - numery klastr贸w
</code></pre><p>P贸藕niej bdziemy odczytywa bardziej skomplikowane tablice alokacji, wic powr贸cimy do tego algorytmu.</p>
<p>Wiemy zatem, 偶e klaster o numerze 0 jest zakodowany jako <code>ff8</code>, a klaster 1 jako <code>fff</code>. Wszystkie pozostae klastry w urzdzeniu s oznaczone jako <code>000</code>. Co te liczby oznaczaj?</p>
<table>
<thead>
<tr>
<th>Warto</th>
<th>Opis</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>000</code></td>
<td>Klaster wolny</td>
</tr>
<tr>
<td><code>002-fef</code></td>
<td>Klaster zajty</td>
</tr>
<tr>
<td><code>ff0-ff6</code></td>
<td>Klaster zarezerwowany</td>
</tr>
<tr>
<td><code>ff7</code></td>
<td>Zy sektor</td>
</tr>
<tr>
<td><code>ff8-fff</code></td>
<td>Ostatni klaster</td>
</tr>
</tbody>
</table>
<p>Wiemy zatem, 偶e klastry 0 i 1 s ostatnimi klastrami. Nasze urzdzenie nie ma jeszcze 偶adnego pliku, wic klastry te nie reprezentuj 偶adnego pliku.</p>
<p>Co to znaczy, 偶e klaster jest ostatni? Poka偶emy to dokadnie p贸藕niej, przy omawianiu plik贸w, kt贸re zajmuj wicej ni偶 jeden klaster.</p>
<h3 id="root-directory-table">Root Directory Table</h3>
<p>Dodajmy w kocu jaki plik do naszego urzdzenia i zobaczmy co si zmieni. Najpierw bdziemy musieli zamontowa nasze urzdzenie <code>fat.img</code> w systemie.</p>
<pre tabindex="0"><code>$ mkdir fs
$ sudo mount -t msdos fat.img fs -o umask=000,loop
</code></pre><p>Po utworzeniu katalogu montujemy do niego nasze urzdzenie. Dodatkowe opcje, kt贸rych u偶ywamy rozwizuj problem uprawnie (umask) i pozwalaj zamontowa plik jako urzdzenie <a href="https://en.wikipedia.org/wiki/Loop_device">Loop Device</a>.</p>
<p>Mo偶emy teraz przej do folderu <code>fs</code>. Bdzie pusty. Utw贸rzmy tam plik.</p>
<pre tabindex="0"><code>$ cd fs
$ echo &#34;Witaj&#34; &gt; hello
</code></pre><p>Powr贸my do naszego <code>fat.img</code> i sprawd藕my jego zawarto. Zanim to jednak zrobimy zapiszmy wszystkie oczekujce zmiany do pamici trwaej poprzez wykonanie <code>sync</code>.</p>
<pre tabindex="0"><code>$ sync
$ od -Ax -tx1z fat.img
[...]
000200 f8 ff ff 00 f0 ff 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
000210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000400 f8 ff ff 00 f0 ff 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
000410 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000600 48 45 4c 4c 4f 20 20 20 20 20 20 20 00 00 00 00  &gt;HELLO       ....&lt;
000610 00 00 00 00 00 00 fc 6d 07 4f 03 00 06 00 00 00  &gt;.......m.O......&lt;
000620 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
004e00 57 69 74 61 6a 0a 00 00 00 00 00 00 00 00 00 00  &gt;Witaj...........&lt;
004e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
019000
</code></pre><p>Pomijam ju偶 wypisywanie Boot Sectora, bo nie ulega on zmianom. Widzimy nazw naszego pliku oraz jego zawarto. Offset <code>600</code> (hex) jest to pocztek tzw. Root Directory Table. Jest to, jak sama nazwa wskazuje, nasz folder g贸wny, kt贸re mo偶e przechowywa pliki i foldery. Ilo plik贸w i folder贸w w nim jest ograniczona. Obecne systemy plik贸w nie posiadaj ju偶 takich ogranicze.</p>
<p>Dane pliku &ldquo;hello&rdquo; s zapisane na 32 bajtach (2 wiersze). Ka偶dy bajt koduje pewn informacj o pliku.</p>
<table>
<thead>
<tr>
<th>Nr bajtu</th>
<th>Opis</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-10</td>
<td>Nazwa pliku (8), rozszerzenie (3)</td>
</tr>
<tr>
<td>11</td>
<td>Atrybuty pliku</td>
</tr>
<tr>
<td>12-21</td>
<td><em>Reserved</em></td>
</tr>
<tr>
<td>22-23</td>
<td>Czas</td>
</tr>
<tr>
<td>24-25</td>
<td>Data</td>
</tr>
<tr>
<td>26-27</td>
<td>Pocztkowy klaster (0 - pusty plik)</td>
</tr>
<tr>
<td>28-31</td>
<td>Rozmiar pliku w bajtach</td>
</tr>
</tbody>
</table>
<p>Po wicej informacji zajrzyj <a href="https://www.win.tue.nl/~aeb/linux/fs/fat/fat-1.html#ss1.4">tutaj</a>.</p>
<h2 id="odczytywanie-kr贸tkiego-pliku">Odczytywanie kr贸tkiego pliku</h2>
<p>Spr贸bujmy odczyta plik <code>hello</code> z naszego urzdzenia w podobny spos贸b jak robi to komputer.</p>
<p>W <em>Root Directory Table</em> po nazwie odnajdujemy nasz plik <code>hello</code>.</p>
<pre tabindex="0"><code>000600 48 45 4c 4c 4f 20 20 20 20 20 20 20 00 00 00 00  &gt;HELLO       ....&lt;
000610 00 00 00 00 00 00 fc 6d 07 4f 03 00 06 00 00 00  &gt;.......m.O......&lt;
</code></pre><p>Odnajduj rozmiar pliku na bajtach 28-31. Jest to wic liczba 4-bajtowa zapisana w <a href="https://pl.wikipedia.org/wiki/Kolejno%C5%9B%C4%87_bajt%C3%B3w">Little Endian</a>. <em>Rozmiar pliku to 6 bajt贸w</em></p>
<table>
<thead>
<tr>
<th>bajty</th>
<th>raw</th>
<th>hex</th>
<th>dec</th>
</tr>
</thead>
<tbody>
<tr>
<td>28-31</td>
<td><code>06 00 00 00</code></td>
<td><code>00000006</code></td>
<td>6</td>
</tr>
</tbody>
</table>
<p>Odczytuj r贸wnie偶 na bajtach 26 i 27 pocztkowy klaster, gdzie znajduje si zawarto tego pliku.</p>
<table>
<thead>
<tr>
<th>bajty</th>
<th>raw</th>
<th>hex</th>
<th>dec</th>
</tr>
</thead>
<tbody>
<tr>
<td>26-27</td>
<td><code>03 00</code></td>
<td><code>0003</code></td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Wiemy, zatem, 偶e <em>trzeci sektor jest sektorem, w kt贸rym zaczyna si nasz plik</em>. Udajemy si do tablicy alokacji i patrzymy jak jest zakodowany trzeci sektor.</p>
<p>Tablica alokacji wyglda tak:</p>
<pre tabindex="0"><code>000200 f8 ff ff 00 f0 ff 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
000210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;.
*
</code></pre><p>Posu偶ymy si algorytmem opisanym wczeniej, aby odczyta kodowania dla poszczeg贸lnych klastr贸w. Jak nabierzesz wprawy, to bdziesz to odczytywa zwykym spojrzeniem na powy偶szy cig bajt贸w (cho nie wiem po co ktokolwiek miaby nabiera wprawy w rcznym odczytywaniu tablicy alokacji).</p>
<pre tabindex="0"><code>f8 ff ff 00 f0 ff     - (1) wypisujemy tablic (bez zer na kocu)
f8 ff ff   00 f0 ff   - (2) czymy bajty w tr贸jki
ff ff f8   ff f0 00   - (3) odwracamy kolejno
fff ff8    fff 000    - (4) sklejamy tr贸jki
ff8 fff    000 fff    - (5) odwracamy

ff8 fff 000 fff - wynik kocowy
[0] [1] [2] [3] - numery klastr贸w
</code></pre><p>Nasz plik zaczyna si od klastra nr 3. Wedug tablicy alokacji, klaster [3] (<code>fff</code>) jest <em>klastrem ostatnim</em> (patrz: &laquo;tabela-alokacji-fat, Tabela z oznaczeniami w tablicy alokacji&raquo;).</p>
<p>Nasz plik zatem skada si tylko z klastra nr 3. Znamy dugo ka偶dego klastra oraz miejsce, gdzie zaczyna si klaster <code>[0]</code>. Przeskakujemy wic zadan liczb klastr贸w i zaczynamy czyta klaster <code>[3]</code> od bajtu 004e00~16~.</p>
<pre tabindex="0"><code>004e00 57 69 74 61 6a 0a 00 00 00 00 00 00 00 00 00 00  &gt;Witaj...........&lt;
004e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
</code></pre><p>Plik w systemie FAT nie mo偶e zajmowa zajmowa na dysku mniej ni偶 jeden klaster. Nawet jeli zawiera kilka liter jak w naszym przypadku. Musimy zatem wiedzie gdzie w klastrze kocz si dane pliku. Odczytalimy wczeniej rozmiar pliku, kt贸ry wynosi <em>6 bajt贸w</em>.</p>
<p>6 pierwszych bajt贸w trzeciego klastra to: <code>Witaj\n</code>. Koniec.</p>
<h2 id="odczytywanie-dugiego-pliku">Odczytywanie dugiego pliku</h2>
<p>Przyj偶yjmy si teraz co si stanie, gdy plik bdzie du偶szy ni偶 jeden klaster. Najpierw musimy taki plik utworzy. Zr贸bmy to inteligentnie. Odczytalimy wczeniej, 偶e klaster skada si z 4 sektor贸w. Jeden sektor ma 512 bajt贸w, zatem klaster pomieci 2048 bajt贸w.</p>
<p>Plik, kt贸ry dodamy bdzie si skada z 2048 literek <code>a</code>, a na koniec dokleimy <code>bcdef</code>. Jeli nasze obliczenia s poprawne, to literki <code>a</code> zostan zapisane do jednego sektora, a dalsza cz pliku <code>bcdef</code> do innego.</p>
<p>Przechodzimy do katalogu <code>fs</code> i generujemy plik.</p>
<pre tabindex="0"><code>$ python -c &#34;print(&#39;a&#39;*2048 + &#39;bcdef&#39;)&#34; &gt; duzy
$ sync
</code></pre><p>Zobaczmy teraz co nam powstao w pliku <code>fat.img</code>.</p>
<pre tabindex="0"><code>000200 f8 ff ff 00 f0 ff 05 f0 ff 00 00 00 00 00 00 00  &gt;................&lt;
000210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000400 f8 ff ff 00 f0 ff 05 f0 ff 00 00 00 00 00 00 00  &gt;................&lt;
000410 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000600 48 45 4c 4c 4f 20 20 20 20 20 20 20 00 00 00 00  &gt;HELLO       ....&lt;
000610 00 00 00 00 00 00 fc 6d 07 4f 03 00 06 00 00 00  &gt;.......m.O......&lt;
000620 44 55 5a 59 20 20 20 20 20 20 20 20 00 00 00 00  &gt;DUZY        ....&lt;
000630 00 00 00 00 00 00 dc 84 07 4f 04 00 06 08 00 00  &gt;.........O......&lt;
000640 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
004e00 57 69 74 61 6a 0a 00 00 00 00 00 00 00 00 00 00  &gt;Witaj...........&lt;
004e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
005600 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61  &gt;aaaaaaaaaaaaaaaa&lt;
*
005e00 62 63 64 65 66 0a 00 00 00 00 00 00 00 00 00 00  &gt;bcdef...........&lt;
005e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
019000
</code></pre><p>Jak ostatnio obciem <em>Boot Sector</em>.</p>
<p>Tym razem z <em>Root Directory Table</em> odczytujemy, 偶e <em>pierwszym sektorem jest sektor [4]</em>. Nie bd tu powtarza procedury odczytywania tego. Postpowanie jest analogiczne co z kr贸tkim plikiem.</p>
<p>Odczytajmy tablic alokacji, kt贸ra zdecydowanie ulega zmianie. Wyglda ona tak:</p>
<pre tabindex="0"><code>000200 f8 ff ff 00 f0 ff 05 f0 ff 00 00 00 00 00 00 00  &gt;................&lt;
000210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
</code></pre><p>Zasady odczytu takie same jak ostatnio.</p>
<pre tabindex="0"><code>f8 ff ff 00 f0 ff 05 f0 ff       - (1) wypisujemy tablic
f8 ff ff   00 f0 ff   05 f0 ff   - (2) czymy w tr贸jki
ff ff f8   ff f0 00   ff f0 05   - (3) odwracamy kolejno
fff ff8    fff 000    fff 005    - (4) sklejamy tr贸jki
ff8 fff    000 fff    005 fff    - (5) odwracamy

ff8 fff 000 fff 005 fff- wynik kocowy
[0] [1] [2] [3] [4] [5]- numery klastr贸w
</code></pre><p>Odczytujemy:</p>
<ul>
<li>Plik <code>duzy</code> zaczyna si od klastra [4].</li>
<li>Patrzymy, a klaster o tym numerze jest kodowany jako <code>005</code>.</li>
<li>Oznacza to, 偶e dalsza cz pliku znajduje si w klastrze [5].</li>
<li>Patrzymy do klastra [5] i odczytujemy <code>fff</code>. Zatem jest to <em>ostatni klaster</em>.</li>
</ul>
<p>Teraz wystarczy przeczyta klastry w kolejnoci <code>[4][5]</code>. Klaster <code>[4]</code> zaczyna si od offsetu <code>005600</code> i rzeczywicie 2048 bajt贸w dalej, tam gdzie spodziewamy si klastra <code>[5]</code> odnajdujemy dalsz cz pliku <code>bcdef</code>.</p>
<p>Myl, 偶e ju偶 <em>czujesz</em> jak ten system dziaa. Oczywicie s to tylko proste operacje. Zachcam do samodzielnego eksperymentowania. Jak system plik贸w bdzie zamiecony, to zawsze mo偶esz utworzy nowy. Spr贸buj np. dopisa co do kt贸rego z plik贸w i sprawd藕 co si stanie
<em>(spoiler: stara wersja pliku sprzed zmiany zostanie zachowana w pamici)</em>.</p>
<h2 id="usuwanie-i-odzyskiwanie-pliku">Usuwanie i odzyskiwanie pliku</h2>
<p>Przechodzimy do jednej z najciekawszych rzeczy, czyli co si dzieje gdy usuwamy plik i czy mo偶na go odzyska. Jeli tak, to jak to zrobi. Tym si teraz zajmiemy.</p>
<p>Nadal bdziemy pracowa na pliku <code>fat.img</code>, kt贸ry mamy z poprzednich paragraf贸w. Jeli Tw贸j obecny po zabawach uleg uszkodzeniu lub zamieceniu, to mo偶esz go odtworzy w ten spos贸b:</p>
<pre tabindex="0"><code>dd if=/dev/zero of=fat.img bs=1024 count=100
mkfs.msdos fat.img
mkdir fs
sudo mount -t msdos fat.img fs -o umask=000,loop
cd fs
echo &#34;Witaj&#34; &gt; hello
python -c &#34;print(&#39;a&#39;*2048 + &#39;bcdef)&#34; &gt; duzy
sync
</code></pre><p>Plik z kt贸rym zaczynamy wyglda nastpujco.</p>
<pre tabindex="0"><code>$ od -Ax -tx1z fat.img
[...]
000200 f8 ff ff 00 f0 ff 05 f0 ff 00 00 00 00 00 00 00  &gt;................&lt;
000210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000400 f8 ff ff 00 f0 ff 05 f0 ff 00 00 00 00 00 00 00  &gt;................&lt;
000410 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000600 48 45 4c 4c 4f 20 20 20 20 20 20 20 00 00 00 00  &gt;HELLO       ....&lt;
000610 00 00 00 00 00 00 fc 6d 07 4f 03 00 06 00 00 00  &gt;.......m.O......&lt;
000620 44 55 5a 59 20 20 20 20 20 20 20 20 00 00 00 00  &gt;DUZY        ....&lt;
000630 00 00 00 00 00 00 dc 84 07 4f 04 00 06 08 00 00  &gt;.........O......&lt;
000640 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
004e00 57 69 74 61 6a 0a 00 00 00 00 00 00 00 00 00 00  &gt;Witaj...........&lt;
004e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
005600 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61  &gt;aaaaaaaaaaaaaaaa&lt;
*
005e00 62 63 64 65 66 0a 00 00 00 00 00 00 00 00 00 00  &gt;bcdef...........&lt;
005e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
019000
</code></pre><p>Mamy zatem dwa pliki. Jeden may i du偶y. Ka偶dy z nich usuniemy i spr贸bujemy odzyska.</p>
<h3 id="usuwanie-kr贸tkiego-pliku">Usuwanie kr贸tkiego pliku</h3>
<p>Sama procedura jest do prosta. Po prostu wchodzimy do kadalogu <code>fs</code> i usuwamy plik <code>hello</code>.</p>
<pre tabindex="0"><code>$ rm hello
$ sync
</code></pre><p>No i poszo. Pliku nie ma, ale pytanie co si w praktyce stao? Okazuje si, 偶e w caym pliku <code>fat.img</code> zmienio si tylko <em>kilka bajt贸w</em>. To wyjania dlaczego usuwanie pliku jest du偶o szybsze ni偶 jego kopiowanie. Dane cay czas siedz na dysku. Poni偶ej wycinek zrzutu pamici po usuniciu pliku <code>hello</code>.</p>
<pre tabindex="0"><code>000400 f8 ff ff 00 00 00 05 f0 ff 00 00 00 00 00 00 00  &gt;................&lt;
000410 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000600 e5 45 4c 4c 4f 20 20 20 20 20 20 20 00 00 00 00  &gt;.ELLO       ....&lt;
000610 00 00 00 00 00 00 fc 6d 07 4f 03 00 06 00 00 00  &gt;.......m.O......&lt;
000620 44 55 5a 59 20 20 20 20 20 20 20 20 00 00 00 00  &gt;DUZY        ....&lt;
000630 00 00 00 00 00 00 dc 84 07 4f 04 00 06 08 00 00  &gt;.........O......&lt;
000640 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
004e00 57 69 74 61 6a 0a 00 00 00 00 00 00 00 00 00 00  &gt;Witaj...........&lt;
004e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
</code></pre><p>Co dokadnie zaszo to:</p>
<ul>
<li>W tablicy alokacji (offset <code>000400</code> i <code>000200</code>) zwolni si klaster [3] zajmowany przez plik <code>hello</code></li>
<li>Bajt z pierwsz liter w nazwie pliku zmieni warto na <code>e5</code>.</li>
</ul>
<p>Plik i jego dane nadal znajduj si na dysku. Oczywicie mo偶e zosta w ka偶dej chwili nadpisany jeli zaczniemy tworzy nowe pliki.</p>
<h3 id="odzyskiwanie-kr贸tkiego-pliku">Odzyskiwanie kr贸tkiego pliku</h3>
<p>Co nale偶y zrobi, aby odzyska ten plik? W przypadku pliku, kt贸ry zajmuje tylko jeden klaster jest to proste.</p>
<ul>
<li>Odnajdujemy plik w <em>Root Directory Table</em> (lub w folderze gdzie si znajdowa)</li>
<li>Odczytujemy klaster od kt贸rego si rozpoczyna ten plik.</li>
<li>Jeli klaster jest oznaczony jako zajty, to ju偶 jest za p贸藕no. Dane zostay nadpisane przez inny plik.</li>
<li>Jeli klaster jest wolny <code>000</code>, to jest szansa, 偶e dane z tego pliku nadal si w nim znajduj.</li>
<li>Rcznie oznaczamy klaster jako zajty <code>fff</code></li>
<li>Zmieniamy bajt w nazwie pliku <code>e5</code> na inny znak, np. liter.</li>
</ul>
<p>Aby to wykona mo偶na posu偶y si jakim Hexedytorem. Jest to oczywiste, gdy dane mamy zapisane w pliku.</p>
<p>Co jeli chcemy to wykona na urzdzeniu typu pendrive? Jest to troch trudniejsze, ale nadal wykonalne. Wystarczy zrzuci z pendrive&rsquo;a pami do pliku, podobnie jak robilimy tworzc plik <code>fat.img</code> programem <code>dd</code>. Nie musimy nawet zrzuca caoci, wystarczy fragment. Po dokonaniu zmian wgrywamy zmodyfikowan pami do urzdzenia (w to samo miejsce, z kt贸rego j pobralimy).</p>
<p>Problemy si zaczynaj, gdy chcemy odzyska du偶y plik. Taki, kt贸ry zajmowa kilka klastr贸w.</p>
<h3 id="usuwanie-dugiego-pliku">Usuwanie dugiego pliku</h3>
<p>Usumy <code>duzy</code> plik i popatrzmy co si stao.</p>
<pre tabindex="0"><code>$ rm duzy
$ sync
</code></pre><p>A oto efekt naszych zmian.</p>
<pre tabindex="0"><code>000200 f8 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
000210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000400 f8 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
000410 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000600 e5 45 4c 4c 4f 20 20 20 20 20 20 20 00 00 00 00  &gt;.ELLO       ....&lt;
000610 00 00 00 00 00 00 fc 6d 07 4f 03 00 06 00 00 00  &gt;.......m.O......&lt;
000620 e5 55 5a 59 20 20 20 20 20 20 20 20 00 00 00 00  &gt;.UZY        ....&lt;
000630 00 00 00 00 00 00 dc 84 07 4f 04 00 06 08 00 00  &gt;.........O......&lt;
000640 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
004e00 57 69 74 61 6a 0a 00 00 00 00 00 00 00 00 00 00  &gt;Witaj...........&lt;
004e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
005600 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61  &gt;aaaaaaaaaaaaaaaa&lt;
*
005e00 62 63 64 65 66 0a 00 00 00 00 00 00 00 00 00 00  &gt;bcdef...........&lt;
005e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
019000
</code></pre><p>Tablica alokacji jest pusta. Wszystkie klastry zajmowane przez plik zostay zwolnione, a pierwszy bajt w nazwie pliku <code>duzy</code> ma warto <code>e5</code>. 呕adnych zaskocze.</p>
<h3 id="odzyskiwanie-dugiego-pliku">Odzyskiwanie dugiego pliku</h3>
<p>Teraz mamy problem i to powa偶ny. Co prawda z <em>Root Directory Table</em> nadal mo偶emy odczyta pierwszy sektor zajmowany przez plik, ale gdy udamy si do tablicy alokacji pod wskazany sektor, to oka偶e si, 偶e jest on wolny <code>000</code>. To wietne wieci, ale pozostaje pytanie, <em>kt贸ry klaster jest tym nastpny</em>?</p>
<p>Po rozmiarze pliku mo偶emy obliczy ile klastr贸w bdzie on zajmowa. Musimy je &ldquo;tylko&rdquo; odnale藕 i to jeszcze <em>w dobrej kolejnoci</em>.</p>
<p>Niestety nie ma tutaj byskotliwego rozwizania tego problemu. Zgadywanie zwykle nie wchodzi w gr. Jest jednak wiele metod, kt贸re pozwol zwikszy szans na odzyskanie takiego pliku. Poni偶ej kilka z nich:</p>
<ul>
<li>Defragmentacja dysku czsto sprawia, 偶e wszystkie klastry pliku znajduj si obok siebie jeden za drugim. Z drugiej strony wykonanie defragmentacji <em>po</em> usuniciu pliku mo偶e &ldquo;zapcha dziury po usunitych plikach&rdquo;, a wic nadpisa ich dane.</li>
<li>Stosowanie r贸偶nego rodzaju heurystyk.</li>
<li>Rozpoznawanie formatu pliku po pierwszym klastrze. Wiemy wtedy jakiej nastpnej czci si spodziewa, np. gdy odzyskujemy plik wideo, to czasami wraz z zakodowanym obrazem znajduj si timestamp&rsquo;y okrelajce moment w filmie.</li>
</ul>
<p>Jest zapewne du偶o wicej sposob贸w. Wiele z nich to tajemnice firm produkujcych oprogramowanie do odzyskiwania danych z dysk贸w. Jeli pr贸bowae kiedy kt贸rego z tych &ldquo;darmowych&rdquo; narzdzi do odzyskiwania plik贸w po ich usuniciu, to wiesz ju偶 teraz dlaczego one z tak atwoci wypisyway usunite pliki z nazwami, a za ich odzyskanie trzeba byo ju偶 zapaci. Odnalezienie usunitych plik贸w jest po prostu banalnie proste.</p>
<p>M贸wi tutaj oczywicie o formacie FAT. Struktury plik贸w zapisanych w NTFS czy ext s zupenie inne i bardziej skomplikowane. Nawet w samym FAT32 jest ju偶 sporo zmian w stosunku do FAT12, kt贸ry przedstawiaem.</p>
<h2 id="podsumowanie">Podsumowanie</h2>
<p>Jeli nigdy wczeniej nie miae, czytelniku, okazji pobawi si z systemem plik贸w, to mam nadziej, 偶e wykonane tutaj eksperymenty i zaprezentowane przykady sporo nauczyy. To dopiero wierzchoek g贸ry lodowej. O samym FAT12 mo偶naby zrobi jeszcze 10 podobnej dugoci artyku贸w. Zamiast to robi, lepszym pomysem jest zapoznanie si z nowszymi systemami plik贸w. Por贸wna om贸wiony tutaj FAT12 z u偶ywanym jeszcze powszechnie na pendrive&rsquo;ach FAT32.</p>
<p>Do czego mo偶e si przyda taka wiedza? Mao kto rcznie grzebie w bajtach, wic wiedza o dziaaniu systemu plik贸w przyda si do napisania oprogramowania, kt贸ry na takim systemie operuje. Poza tym daje og贸lne <em>zrozumienie wielu proces贸w, kt贸re zachodz w komputerze</em>. Mimo, 偶e o tym nie wspomniaem, to po przeczytaniu tego artykuu powiniene ju偶 rozumie dlaczego w Windowsie ka偶dy plik ma <em>rozmiar</em> i <em>rozmiar na dysku</em>. To tak jak nasz kr贸tki plik, kt贸ry mia rozmiar 6 bajt贸w, a na dysku zajmowa jeden klaster, a wic 2 kB. To spore marnotrawstwo pamici i wsp贸czesne systemy plik贸w lepiej sobie z tym radz.</p>
<!-- | Dygresja o NTFS |
| :-------------: |
| W NTFS na Windowsie jest troch inaczej. Zr贸b eksperyment. Utw贸rz w Windowsie pusty plik i sprawd藕 jego _rozmiar_ i _rozmiar na dysku_. Oba bd wynosi 0 B. Dodaj literk `a` do pliku, zapisz i sprawd藕. Ile wynosi rozmiar? 1 B. Rozmiar na dysku nadal 0 B. NTFS dziaa troch inaczej i jest w stanie dane kr贸tkich plik贸w zmieci wraz z nazw w jednym rekordzie bez zajmowania caego klastra. Po zwikszeniu pliku do 1 kB, rozmiar na dysku wyniesie 4 kB (w moim przypadku). Po zmniejszeniu pliku do 1 B, rozmiar na dysku pozostaje 4 kB. Wida, 偶e ten system plik贸w jest inteligentniejszy. | -->
<blockquote>
<p><strong>Dygresja o NTFS</strong></p>
<p>W NTFS na Windowsie jest troch inaczej. Zr贸b eksperyment. Utw贸rz w Windowsie pusty plik i sprawd藕 jego <em>rozmiar</em> i <em>rozmiar na dysku</em>. Oba bd wynosi 0 B. Dodaj literk <code>a</code> do pliku, zapisz i sprawd藕. Ile wynosi rozmiar? 1 B. Rozmiar na dysku nadal 0 B. NTFS dziaa troch inaczej i jest w stanie dane kr贸tkich plik贸w zmieci wraz z nazw w jednym rekordzie bez zajmowania caego klastra. Po zwikszeniu pliku do 1 kB, rozmiar na dysku wyniesie 4 kB (w moim przypadku). Po zmniejszeniu pliku do 1 B, rozmiar na dysku pozostaje 4 kB. Wida, 偶e ten system plik贸w jest inteligentniejszy.</p>
</blockquote>

  </main>
  <footer>
    
<div class="footer-links">
    <p><a href="https://github.com/KyrietS">github</a></p>
    <p><a href="/projects">projekty</a></p>
    <p><a href="/">o mnie</a></p>
    <p><a href="/contact">kontakt</a></p>
</div>


<div class="footer-last-edited">
  <a target="_blank" href="https://github.com/KyrietS/blog/commit/a0f061a0f1f39d0b171f58a53867cd03fac9c3d9">Ostatnia modyfikacja: 2024-02-12</a>
</div>

  </footer>
</body>


<script src="/js/main.js"></script>

<!--Szata graficzna tego bloga zostaa "zainspirowana"  z tego bloga: https://thomashope.xyz/ -->
</html>
