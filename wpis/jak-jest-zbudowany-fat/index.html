<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Sebastian Fojcik">
    <meta name="description" content="Opis strony, który może mieć kilka linii.">
    <meta name="keywords" content="blog, programowanie, studia, informatyka">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="/css/w3.css">
    <link rel="stylesheet" href="/css/style.css">

    <!-- Zestaw ikon wygenerowano przy użyciu: https://realfavicongenerator.net/ -->
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="/assets/icons/site.webmanifest">
    <link rel="mask-icon" href="/assets/icons/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="/assets/icons/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="/assets/icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">


    <title>Jak jest zbudowany system plików FAT</title>
</head>
<body>

<div id="mobile-navbar" class="w3-row w3-hide-medium w3-hide-large w3-card w3-center w3-green">
    <i onclick="nav_open()" class="fa fa-bars w3-xlarge w3-button w3-theme w3-left"></i> 
    <span style="line-height: 40px; margin-left: -56px;">Kyriet'Stuff</span>
</div>

  <!-- Header -->
<header class="w3-container w3-center w3-padding-32" id="page-header">
    <div id="page-logo">
        <img src="/assets/img/logo.svg" alt="Logo" class="logo w3-animate-left" style="width: 100px;" 
            onerror="this.src='/assets/img/logo.png'">
    </div>
    <div id="page-title">
        <h1 class="w3-xxxlarge w3-animate-top"> KYRIET'STUFF</h1>
        <h4 class="w3-animate-bottom">KTO PYTA, NIE BŁĄDZI. KTO SZUKA, TEN WIE.</h4>
    </div>
</header>

<!-- Nawigacja -->
<nav id="navigation" class="w3-sidebar w3-bar w3-bar-block w3-card-2 w3-animate-left w3-center w3-light-gray" style="display:none">
    <div class="w3-content">

        <button class="w3-bar-item w3-button w3-hide-medium w3-hide-large" style="border-bottom: 1px solid lightgray;" onclick="nav_close()">Zamknij <i class="fa fa-remove"></i></button>

        <a href="/" class="w3-bar-item w3-button w3-mobile">Start</a>

        <div class="w3-dropdown-click w3-center">
            <button id="dropdown-categories-button" class="w3-button">
                Kategorie <i class="fa fa-caret-down"></i>
            </button>
            <div id="dropdown-categories" class="w3-dropdown-content w3-bar-block w3-card">

                
                
                
                    <a href="/kategoria/processing" class="w3-bar-item w3-button">Processing</a>
                
                
                
                    <a href="/kategoria/programowanie" class="w3-bar-item w3-button">Programowanie</a>
                
                
                
                    <a href="/kategoria/systemy-operacyjne" class="w3-bar-item w3-button">Systemy operacyjne</a>
                
                
                
                    <a href="/kategoria/webowka" class="w3-bar-item w3-button">Webówka</a>
                

                <!-- <a href="category.html" class="w3-bar-item w3-button">Programowanie</a>
                <a href="#" class="w3-bar-item w3-button">Informatyka</a>
                <a href="#" class="w3-bar-item w3-button">Warsztat</a> -->
            </div>
        </div>

        <a href="/projekty/" class="w3-bar-item w3-button w3-mobile">Moje projekty</a>
        <a href="/kontakt/" class="w3-bar-item w3-button w3-mobile">Kontakt</a>

        <!-- Wyszukaj -->
        <form action="/wyszukaj/" method="get" class="w3-right" autocomplete="off">
            <button class="w3-bar-item w3-right w3-button w3-green w3-mobile"><i class="fa fa-search"></i></button>
            <input type="text" id="dropdown-search-input" class="w3-bar-item w3-input w3-white w3-mobile w3-border-left w3-left-align" 
                style="display: inline-block; float: none;" placeholder="Wyszukaj..." name="s">
            <div id="dropdown-search" class="w3-dropdown-content w3-card w3-bar-block">
                <div id="dropdown-search-results"></div>
                <span id="dropdown-search-info" class="w3-bar-item">Kilka niedawnych wpisów.<br>Wciśniej enter, aby wyszukać dokładniej.</span>
            </div>
        </form>

    </div>
</nav>
<div class="nav-gap"></div>

<main class="w3-content w3-padding-small">
    <article>
        <header>
            <h1>Jak jest zbudowany system plików FAT</h1>
            <p>02.05.2020

                
                
                    | <a href="/kategoria/systemy-operacyjne">Systemy operacyjne</a>
                

                | <i>Sebastian Fojcik</i></p>
        </header>

        <img src="/assets/posts/thumbnails/system-plikow.png" alt="Miniaturka do wpisu" class="w3-left" id="thumbnail">

        <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>W tym wpisie podstawowe zasady działania systemu plików z rodziny FAT. Jeśli jesteś ciekawy co się dzieje "pod maską", gdy dodajesz lub usuwasz plik na nośniku danych z systemem plików FAT, to zachęcam do lektury tego wpisu. Na przykładach i w praktyce pokażę jakie zmiany zachodzą na dysku podczas manipulacji plikami.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="z-tego-wpisu-dowiesz-się"><a class="anchor" href="#z-tego-wpisu-dowiesz-się"></a>Z tego wpisu dowiesz się</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Jakie informacje można znaleźć w <em>Boot Sector</em></p>
</li>
<li>
<p>Czym jest tablica alokacji (FAT)</p>
</li>
<li>
<p>Jak reprezentowany jest plik na dysku z systemem FAT</p>
</li>
<li>
<p>Jak przywrócić plik po usunięciu go z dysku z systemem FAT</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="czym-jest-system-plików"><a class="anchor" href="#czym-jest-system-plików"></a>Czym jest system plików</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>System plików</strong> jest to metoda przechowywania i zarządzania danymi na nośniku pamięci. Najmniejszą porcję danych użytkownika w systemie plików najczęściej stanowi plik. Do opisania budowy FAT potrzebne nam będą bardziej szczegółowe pojęcia: <em>bajt</em>, <em>sektor</em> i <em>klaster</em>. Definicja ta nie jest szczególnie istotna i przydatna w życiu. Jeśli potrzebujesz to wiedzieć do kolokwium, to zajrzyj do <a href="https://pl.wikipedia.org/wiki/System_plik%C3%B3w">Wikipedii</a>.</p>
</div>
<div class="paragraph">
<p>Po przeczytaniu tego wpisu <em>wyczujesz</em> czym jest system plików i będziesz się czuł pewnie, aby opowiedzieć co taki system robi.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="budowa-fat"><a class="anchor" href="#budowa-fat"></a>Budowa FAT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Zacznijmy od pokazania jak taki system plików wygląda. Wszystkie czynności tutaj przedstawione wykonuję na komputerze z systemem Linux Mint.</p>
</div>
<div class="sect2">
<h3 id="utworzenie-czystego-systemu-plików-fat"><a class="anchor" href="#utworzenie-czystego-systemu-plików-fat"></a>Utworzenie czystego systemu plików FAT</h3>
<div class="paragraph">
<p>Będziemy potrzebowali urządzenia do testów. Takiego, na którym będziemy mogli wykonywać normalne operacje na plikach (utwórz, kopiuj, usuń). Niezbędna jest również możliwość niskopoziomowego podglądu jak dane są zapisane na nośniku (bajt po bajcie).</p>
</div>
<div class="paragraph">
<p>Na szczęście nie będziemy używać fizycznego urządzenia. Stworzymy plik, który następnie zamontujemy w systemie jako wirtualny "nośnik danych". Można sobie to zestawić z analogią do fizycznego pendrive&#8217;a. Plik to nasz pendrive, a montowanie pliku w systemie, to po prostu wpięcie pendriva do komputera (coś jak plik z formatem <em>*.iso</em>).</p>
</div>
<div class="paragraph">
<p>Najpierw utwórzmy pusty plik o rozmiarze, powiedzmy 100kB. Rozmiar pliku w tym przypadku będzie oznaczał pojemność naszego wirtualnego urządzenia.<br>
<strong>Uwaga</strong>: plikowi nie można tak po prostu nadać rozmiaru. Trzeba go czymś wypełnić. Tworzę więc plik o nazwie <code>{fat.img}</code> i wypełniam go bajtami o wartości zero (nie mylić z wypełnianiem pliku znakami cyfry '0').</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">$ dd if=/dev/zero of=fat.img bs=1024 count=100</pre>
</div>
</div>
<div class="paragraph">
<p>Utworzyliśmy w ten sposób plik o rozmiarze 100kB. Dane tego pliku składają się z samych zer. Jest to plik binarny, więc wyświetlanie jego zawartości programami typu <code>less</code> czy <code>cat</code> nie jest dobrym pomysłem.</p>
</div>
<div class="paragraph">
<p>Zobaczmy jak wygląda:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">$ hexdump -C fat.img

00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00019000</pre>
</div>
</div>
<div class="paragraph">
<p>Widać, że plik jest wypełniony zerami. Program hexdump inteligentnie pokazuje tylko pierwsze 16 bajtów, po których wstawia znak <code>*</code> oznaczający, że ta sekwencja się powtarza aż do offsetu <code>00019000</code>, czyli do samego końca pliku (19000<sub>16</sub> = 102400<sub>10</sub>).</p>
</div>
<div class="paragraph">
<p>Stwórzmy w końcu system plików w naszym pliku.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">$ mkfs.msods fat.img

mkfs.fat 4.1 (2017-01-24)</pre>
</div>
</div>
<div class="paragraph">
<p>Dlaczego używam tutaj prehistorycznego FAT12? Ponieważ jest najprostszy w budowie i pozwoli w prosty sposób pokazać omawiane zagadnienia. Późniejsza analiza, np. FAT32 będzie o wiele łatwiejsza znając już podstawy.</p>
</div>
<div class="paragraph">
<p>Zerknijmy teraz jak wygląda nasz plik w środku.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">$ hexdump -C fat.img
00000000  eb 3c 90 6d 6b 66 73 2e  66 61 74 00 02 04 01 00  |.&lt;.mkfs.fat.....|
00000010  02 00 02 c8 00 f8 01 00  20 00 40 00 00 00 00 00  |........ .@.....|
00000020  00 00 00 00 80 00 29 9c  38 71 69 4e 4f 20 4e 41  |......).8qiNO NA|
00000030  4d 45 20 20 20 20 46 41  54 31 32 20 20 20 0e 1f  |ME    FAT12   ..|
00000040  be 5b 7c ac 22 c0 74 0b  56 b4 0e bb 07 00 cd 10  |.[|.".t.V.......|
00000050  5e eb f0 32 e4 cd 16 cd  19 eb fe 54 68 69 73 20  |^..2.......This |
00000060  69 73 20 6e 6f 74 20 61  20 62 6f 6f 74 61 62 6c  |is not a bootabl|
00000070  65 20 64 69 73 6b 2e 20  20 50 6c 65 61 73 65 20  |e disk.  Please |
00000080  69 6e 73 65 72 74 20 61  20 62 6f 6f 74 61 62 6c  |insert a bootabl|
00000090  65 20 66 6c 6f 70 70 79  20 61 6e 64 0d 0a 70 72  |e floppy and..pr|
000000a0  65 73 73 20 61 6e 79 20  6b 65 79 20 74 6f 20 74  |ess any key to t|
000000b0  72 79 20 61 67 61 69 6e  20 2e 2e 2e 20 0d 0a 00  |ry again ... ...|
000000c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|
00000200  f8 ff ff 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000210  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000400  f8 ff ff 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000410  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00019000</pre>
</div>
</div>
<div class="paragraph">
<p>Otrzymaliśmy pusty system plików na naszym urządzeniu. Gdybyśmy przy tworzeniu systemu plików zamiast pliku <code>fat.img</code> podali ścieżkę do zamontowanego pendrive&#8217;a, to byśmy go w ten sposób sformatowali i ustawili na nim system plików FAT12.</p>
</div>
</div>
<div class="sect2">
<h3 id="budowa-boot-sectora-w-fat12"><a class="anchor" href="#budowa-boot-sectora-w-fat12"></a>Budowa Boot Sectora w FAT12</h3>
<div class="paragraph">
<p>Pierwsze 512 bajtów, a więc do offsetu <code>000001f0</code> zajmuje tzw. <em>Boot sector</em>*_ naszego urządzenia. Znajdują się tam szczegółowe informacje o używanym systemie plików na urządzeniu. Boot sector w FAT zawsze kończy się sekwencją <code>55 aa</code>.</p>
</div>
<div class="paragraph">
<p>Po pełny opis co oznacza który bajt w tym sektorze możesz odwiedzić <a href="https://www.win.tue.nl/~aeb/linux/fs/fat/fat-1.html#ss1.2">tę stronę</a>.</p>
</div>
<div class="paragraph">
<p>Ja wypiszę kilka ciekawych i najważniejszych wartości.</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Nr bajtu</th>
<th class="tableblock halign-left valign-top">Opis</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">11-12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Liczba <strong>bajtów</strong> na jeden <strong>sektor</strong>.&lt;br&gt;Dozwolone wartości: 512, 1024, 2048, 3096.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Liczba <strong>sektorów</strong> na jeden <strong>klaster</strong>.&lt;br&gt;Dozwolone wartości: 1, 2, 4, 8, 16, 32, 64, 128</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Liczba kopii <strong>FAT (tablicy alokacji)</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">22-23</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Liczba sektorów na jedną tablicę alokacji</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">510-511</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sygnatura <code>55 aa</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Zerknijmy jeszcze raz na <em>Boot Sector</em>, tym razem dla ułatwienia z offsetem dziesiętnym i spróbujmy odczytać z niego wartości posługując się tabelą powyżej.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">$ od -Ad -tx1z fat.img
0000000 eb 3c 90 6d 6b 66 73 2e 66 61 74 00 02 04 01 00  &gt;.&lt;.mkfs.fat.....&lt;
0000016 02 00 02 c8 00 f8 01 00 20 00 40 00 00 00 00 00  &gt;........ .@.....&lt;
0000032 00 00 00 00 80 00 29 9c 38 71 69 4e 4f 20 4e 41  &gt;......).8qiNO NA&lt;
0000048 4d 45 20 20 20 20 46 41 54 31 32 20 20 20 0e 1f  &gt;ME    FAT12   ..&lt;
0000064 be 5b 7c ac 22 c0 74 0b 56 b4 0e bb 07 00 cd 10  &gt;.[|.".t.V.......&lt;
0000080 5e eb f0 32 e4 cd 16 cd 19 eb fe 54 68 69 73 20  &gt;^..2.......This &lt;
0000096 69 73 20 6e 6f 74 20 61 20 62 6f 6f 74 61 62 6c  &gt;is not a bootabl&lt;
0000112 65 20 64 69 73 6b 2e 20 20 50 6c 65 61 73 65 20  &gt;e disk.  Please &lt;
0000128 69 6e 73 65 72 74 20 61 20 62 6f 6f 74 61 62 6c  &gt;insert a bootabl&lt;
0000144 65 20 66 6c 6f 70 70 79 20 61 6e 64 0d 0a 70 72  &gt;e floppy and..pr&lt;
0000160 65 73 73 20 61 6e 79 20 6b 65 79 20 74 6f 20 74  &gt;ess any key to t&lt;
0000176 72 79 20 61 67 61 69 6e 20 2e 2e 2e 20 0d 0a 00  &gt;ry again ... ...&lt;
0000192 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
0000496 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa  &gt;..............U.&lt;
0000512 f8 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
0000528 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
0001024 f8 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
0001040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
0102400</pre>
</div>
</div>
<div class="paragraph">
<p>Bajty liczymy od zera, więc bajt numer 1 ma wartość <code>3c</code>, bajt numer <code>16 02</code> itd.</p>
</div>
<div class="paragraph">
<p>Spróbuj samodzielnie odczytać wartości z Boot Sectora. Odpowiedzi zamieszczam w tabeli poniżej.</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Pole</th>
<th class="tableblock halign-left valign-top">raw</th>
<th class="tableblock halign-left valign-top">hex</th>
<th class="tableblock halign-left valign-top">dec</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Liczba bajtów na sektor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>00 02</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0200</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>512</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Liczba sektorów na klaster</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>04</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>04</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Liczba kopii FAT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>02</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>02</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Liczba sektorów na FAT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>01 00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0001</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Mimo tego, że Boot Sector mamy przedstawiony w postaci ciągu bajtów zapisanych szesnastkowo, muszę rozróżniać tutaj wartość odczytaną (raw) od wartości liczbowej, którą reprezentuje ten zapis (hex). Wartość uzyskamy czytając bajty w odwrotnej kolejności. Jeśli nie rozumiesz dlaczego, przeczytaj o formie zapisu <a href="https://pl.wikipedia.org/wiki/Kolejno%C5%9B%C4%87_bajt%C3%B3w">Little Endian</a>.</p>
</div>
<div class="paragraph">
<p>Z opisów z tabel już się pewnie domyślasz jaki stosunek do siebie mają <em>bajty</em>, <em>sektory</em> i |<em>klastry</em>.</p>
</div>
<div class="paragraph">
<p><strong>Sektor</strong> to zbiór <strong>bajtów</strong> o stałym rozmiarze.
<strong>Klaster</strong> to zbiór <strong>sektorów</strong> o stałym rozmiarze.</p>
</div>
<div class="paragraph">
<p>Mamy informację, że tablica alokacji FAT <em>(File Allocation Table)</em> składa się z jednego sektora, a więc z 512 bajtów. Wiemy również, że nasz system plików przechowuje 2 kopie tablicy alokacji (jest to pewna forma zabezpieczenia). Sprawdźmy, czy to co odczytaliśmy z <em>Boot Sectora</em> się zgadza.</p>
</div>
<div class="paragraph">
<p>Dokładnie od offsetu 512 zaczyna się pierwsza tablica alokacji FAT, która kończy się 512 bajtów dalej. Następnie zaczyna się identyczna kopia FAT. Są tam już wpisane jakieś wartości. Omówimy je za moment.</p>
</div>
</div>
<div class="sect2">
<h3 id="budowa-tablicy-alokacji-fat"><a class="anchor" href="#budowa-tablicy-alokacji-fat"></a>Budowa tablicy alokacji FAT</h3>
<div class="paragraph">
<p>Tablica alokacji jest taką mapą po pamięci. Jeśli mamy jakiś duży plik, który zajmuje kilka sektorów, tablica alokacji powie nam które kolejne sektory powinniśmy odczytywać, aby otrzymać cały plik.</p>
</div>
<div class="paragraph">
<p>W FAT12 jeden klaster jest kodowany na 12 bitach, a więc 3 bajtach. Powoduje to trochę komplikacji przy próbie ręcznego odczytywania wartości z postaci szesnastkowej, którą my mamy. Dla FAT16 i FAT32 jest to dużo prostsze.</p>
</div>
<div class="paragraph">
<p>Odczytajmy zawartość tablicy alokacji, bo widać, że już coś się tam w niej znajduje. Zaczynamy od offsetu 512. Algorytm jest następujący:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Wypisz bajty z tablicy alokacji. Zera z końca możemy pominąć.</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">f8 ff ff</pre>
</div>
</div>
</li>
<li>
<p>Łączymy bajty w trójki od lewej do prawej (w naszym przypadku mamy już trójkę, więc nic nie robimy).</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">ff ff f8</pre>
</div>
</div>
</li>
<li>
<p>Przepisujemy wszystkie <strong>bajty</strong> w trójkach, w odwrotnej kolejności
(Taki zapis: <code>ff ff 8f</code> <strong>nie</strong> jest poprawnym odwróceniem bajtów).</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">ff ff f8</pre>
</div>
</div>
</li>
<li>
<p>Wybrane trójki dzielimy na dwie równe części.</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">fff ff8</pre>
</div>
</div>
</li>
<li>
<p>Każdą z par odczytujemy w odwróconej kolejności. Otrzymaliśmy tablicę alokacji w postaci szesnastkowej.</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">ff8 fff
[0] [1] - numery klastrów</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Później będziemy odczytywać bardziej skomplikowane tablice alokacji, więc powrócimy do tego algorytmu.</p>
</div>
<div class="paragraph">
<p>Wiemy zatem, że klaster o numerze 0 jest zakodowany jako <code>ff8</code>, a klaster 1 jako <code>fff</code>. Wszystkie pozostałe klastry w urządzeniu są oznaczone jako <code>000</code>. Co te liczby oznaczają?</p>
</div>
<table id="tabela-alokacji-fat" class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Wartość</th>
<th class="tableblock halign-left valign-top">Opis</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>000</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Klaster wolny</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>002-fef</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Klaster zajęty</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ff0-ff6</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Klaster zarezerwowany</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ff7</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Zły sektor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ff8-fff</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ostatni klaster</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Wiemy zatem, że klastry 0 i 1 są ostatnimi klastrami. Nasze urządzenie nie ma jeszcze żadnego pliku, więc klastry te nie reprezentują żadnego pliku.</p>
</div>
<div class="paragraph">
<p>Co to znaczy, że klaster jest ostatni? Pokażemy to dokładnie później, przy omawianiu plików, które zajmują więcej niż jeden klaster.</p>
</div>
</div>
<div class="sect2">
<h3 id="root-directory-table"><a class="anchor" href="#root-directory-table"></a>Root Directory Table</h3>
<div class="paragraph">
<p>Dodajmy w końcu jakiś plik do naszego urządzenia i zobaczmy co się zmieni. Najpierw będziemy musieli zamontować nasze urządzenie <code>fat.img</code> w systemie.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">$ mkdir fs
$ sudo mount -t msdos fat.img fs -o umask=000,loop</pre>
</div>
</div>
<div class="paragraph">
<p>Po utworzeniu katalogu montujemy do niego nasze urządzenie. Dodatkowe opcje, których używamy rozwiązują problem uprawnień (umask) i pozwalają zamontować plik jako urządzenie <a href="https://en.wikipedia.org/wiki/Loop_device">Loop Device</a>.</p>
</div>
<div class="paragraph">
<p>Możemy teraz przejść do folderu <code>fs</code>. Będzie pusty. Utwórzmy tam plik.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">$ cd fs
$ echo "Witaj" &gt; hello</pre>
</div>
</div>
<div class="paragraph">
<p>Powróćmy do naszego <code>fat.img</code> i sprawdźmy jego zawartość. Zanim to jednak zrobimy zapiszmy wszystkie oczekujące zmiany do pamięci trwałej poprzez wykonanie <code>sync</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">$ sync
$ od -Ax -tx1z fat.img
[...]
000200 f8 ff ff 00 f0 ff 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
000210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000400 f8 ff ff 00 f0 ff 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
000410 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000600 48 45 4c 4c 4f 20 20 20 20 20 20 20 00 00 00 00  &gt;HELLO       ....&lt;
000610 00 00 00 00 00 00 fc 6d 07 4f 03 00 06 00 00 00  &gt;.......m.O......&lt;
000620 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
004e00 57 69 74 61 6a 0a 00 00 00 00 00 00 00 00 00 00  &gt;Witaj...........&lt;
004e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
019000</pre>
</div>
</div>
<div class="paragraph">
<p>Pomijam już wypisywanie Boot Sectora, bo nie ulega on zmianom. Widzimy nazwę naszego pliku oraz jego zawartość. Offset <code>600</code> (hex) jest to początek tzw. Root Directory Table. Jest to, jak sama nazwa wskazuje, nasz folder główny, które może przechowywać pliki i foldery. Ilość plików i folderów w nim jest ograniczona. Obecne systemy plików nie posiadają już takich ograniczeń.</p>
</div>
<div class="paragraph">
<p>Dane pliku "hello" są zapisane na 32 bajtach (2 wiersze). Każdy bajt koduje pewną informację o pliku.</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Nr bajtu</th>
<th class="tableblock halign-left valign-top">Opis</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0-10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nazwa pliku (8), rozszerzenie (3)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Atrybuty pliku</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">12-21</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">22-23</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Czas</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">24-25</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">26-27</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Początkowy klaster (0 - pusty plik)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">28-31</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rozmiar pliku w bajtach</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Po więcej informacji zajrzyj <a href="https://www.win.tue.nl/~aeb/linux/fs/fat/fat-1.html#ss1.4">tutaj</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="odczytywanie-krótkiego-pliku"><a class="anchor" href="#odczytywanie-krótkiego-pliku"></a>Odczytywanie krótkiego pliku</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spróbujmy odczytać plik <code>hello</code> z naszego urządzenia w podobny sposób jak robi to komputer.</p>
</div>
<div class="paragraph">
<p>W <em>Root Directory Table</em> po nazwie odnajdujemy nasz plik <code>hello</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">000600 48 45 4c 4c 4f 20 20 20 20 20 20 20 00 00 00 00  &gt;HELLO       ....&lt;
000610 00 00 00 00 00 00 fc 6d 07 4f 03 00 06 00 00 00  &gt;.......m.O......&lt;</pre>
</div>
</div>
<div class="paragraph">
<p>Odnajduję rozmiar pliku na bajtach 28-31. Jest to więc liczba 4-bajtowa zapisana w <a href="https://pl.wikipedia.org/wiki/Kolejno%C5%9B%C4%87_bajt%C3%B3w">Little Endian</a>. <strong>Rozmiar pliku to 6 bajtów</strong></p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">bajty</th>
<th class="tableblock halign-left valign-top">raw</th>
<th class="tableblock halign-left valign-top">hex</th>
<th class="tableblock halign-left valign-top">dec</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">28-31</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>06 00 00 00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>00000006</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>6</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Odczytuję również na bajtach 26 i 27 początkowy klaster, gdzie znajduje się zawartość tego pliku.</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">bajty</th>
<th class="tableblock halign-left valign-top">raw</th>
<th class="tableblock halign-left valign-top">hex</th>
<th class="tableblock halign-left valign-top">dec</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">26-27</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>03 00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0003</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>3</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Wiemy, zatem, że <strong>trzeci sektor jest sektorem, w którym zaczyna się nasz plik</strong>. Udajemy się do tablicy alokacji i patrzymy jak jest zakodowany trzeci sektor.</p>
</div>
<div class="paragraph">
<p>Tablica alokacji wygląda tak:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">000200 f8 ff ff 00 f0 ff 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
000210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;.
*</pre>
</div>
</div>
<div class="paragraph">
<p>Posłużymy się algorytmem opisanym wcześniej, aby odczytać kodowania dla poszczególnych klastrów. Jak nabierzesz wprawy, to będziesz to odczytywać zwykłym spojrzeniem na powyższy ciąg bajtów (choć nie wiem po co ktokolwiek miałby nabierać wprawy w ręcznym odczytywaniu tablicy alokacji).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">f8 ff ff 00 f0 ff     - (1) wypisujemy tablicę (bez zer na końcu)
f8 ff ff   00 f0 ff   - (2) łączymy bajty w trójki
ff ff f8   ff f0 00   - (3) odwracamy kolejność
fff ff8    fff 000    - (4) sklejamy trójki
ff8 fff    000 fff    - (5) odwracamy

ff8 fff 000 fff - wynik końcowy
[0] [1] [2] [3] - numery klastrów</pre>
</div>
</div>
<div class="paragraph">
<p>Nasz plik zaczyna się od klastra nr 3. Według tablicy alokacji, klaster [3] (<code>fff</code>) jest <strong>klastrem ostatnim</strong> (patrz: <a href="#tabela-alokacji-fat">Tabela z oznaczeniami w tablicy alokacji</a>).</p>
</div>
<div class="paragraph">
<p>Nasz plik zatem składa się tylko z klastra nr 3. Znamy długość każdego klastra oraz miejsce, gdzie zaczyna się klaster <code>[0]</code>. Przeskakujemy więc zadaną liczbę klastrów i zaczynamy czytać klaster <code>[3]</code> od bajtu 004e00<sub>16</sub>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">004e00 57 69 74 61 6a 0a 00 00 00 00 00 00 00 00 00 00  &gt;Witaj...........&lt;
004e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*</pre>
</div>
</div>
<div class="paragraph">
<p>Plik w systemie FAT nie może zajmować zajmować na dysku mniej niż jeden klaster. Nawet jeśli zawiera kilka liter jak w naszym przypadku. Musimy zatem wiedzieć gdzie w klastrze kończą się dane pliku. Odczytaliśmy wcześniej rozmiar pliku, który wynosi <strong>6 bajtów</strong>.</p>
</div>
<div class="paragraph">
<p>6 pierwszych bajtów trzeciego klastra to: <code>Witaj\n</code>. Koniec.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="odczytywanie-długiego-pliku"><a class="anchor" href="#odczytywanie-długiego-pliku"></a>Odczytywanie długiego pliku</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Przyjżyjmy się teraz co się stanie, gdy plik będzie dłuższy niż jeden klaster. Najpierw musimy taki plik utworzyć. Zróbmy to inteligentnie. Odczytaliśmy wcześniej, że klaster składa się z 4 sektorów. Jeden sektor ma 512 bajtów, zatem klaster pomieści 2048 bajtów.</p>
</div>
<div class="paragraph">
<p>Plik, który dodamy będzie się składał z 2048 literek <code>a</code>, a na koniec dokleimy <code>bcdef</code>. Jeśli nasze obliczenia są poprawne, to literki <code>a</code> zostaną zapisane do jednego sektora, a dalsza część pliku <code>bcdef</code> do innego.</p>
</div>
<div class="paragraph">
<p>Przechodzimy do katalogu <code>fs</code> i generujemy plik.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">$ python -c "print('a'*2048 + 'bcdef')" &gt; duzy
$ sync</pre>
</div>
</div>
<div class="paragraph">
<p>Zobaczmy teraz co nam powstało w pliku <code>fat.img</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">000200 f8 ff ff 00 f0 ff 05 f0 ff 00 00 00 00 00 00 00  &gt;................&lt;
000210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000400 f8 ff ff 00 f0 ff 05 f0 ff 00 00 00 00 00 00 00  &gt;................&lt;
000410 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000600 48 45 4c 4c 4f 20 20 20 20 20 20 20 00 00 00 00  &gt;HELLO       ....&lt;
000610 00 00 00 00 00 00 fc 6d 07 4f 03 00 06 00 00 00  &gt;.......m.O......&lt;
000620 44 55 5a 59 20 20 20 20 20 20 20 20 00 00 00 00  &gt;DUZY        ....&lt;
000630 00 00 00 00 00 00 dc 84 07 4f 04 00 06 08 00 00  &gt;.........O......&lt;
000640 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
004e00 57 69 74 61 6a 0a 00 00 00 00 00 00 00 00 00 00  &gt;Witaj...........&lt;
004e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
005600 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61  &gt;aaaaaaaaaaaaaaaa&lt;
*
005e00 62 63 64 65 66 0a 00 00 00 00 00 00 00 00 00 00  &gt;bcdef...........&lt;
005e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
019000</pre>
</div>
</div>
<div class="paragraph">
<p>Jak ostatnio obciąłem <em>Boot Sector</em>.</p>
</div>
<div class="paragraph">
<p>Tym razem z <em>Root Directory Table</em> odczytujemy, że <strong>pierwszym sektorem jest sektor [4]</strong>. Nie będę tu powtarzał procedury odczytywania tego. Postępowanie jest analogiczne co z krótkim plikiem.</p>
</div>
<div class="paragraph">
<p>Odczytajmy tablicę alokacji, która zdecydowanie uległa zmianie. Wygląda ona tak:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">000200 f8 ff ff 00 f0 ff 05 f0 ff 00 00 00 00 00 00 00  &gt;................&lt;
000210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*</pre>
</div>
</div>
<div class="paragraph">
<p>Zasady odczytu takie same jak ostatnio.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">f8 ff ff 00 f0 ff 05 f0 ff       - (1) wypisujemy tablicę
f8 ff ff   00 f0 ff   05 f0 ff   - (2) łączymy w trójki
ff ff f8   ff f0 00   ff f0 05   - (3) odwracamy kolejność
fff ff8    fff 000    fff 005    - (4) sklejamy trójki
ff8 fff    000 fff    005 fff    - (5) odwracamy

ff8 fff 000 fff 005 fff- wynik końcowy
[0] [1] [2] [3] [4] [5]- numery klastrów</pre>
</div>
</div>
<div class="paragraph">
<p>Odczytujemy
- Plik <code>duzy</code> zaczyna się od klastra [4].
- Patrzymy, a klaster o tym numerze jest kodowany jako <code>005</code>.
- Oznacza to, że dalsza część pliku znajduje się w klastrze [5].
- Patrzymy do klastra [5] i odczytujemy <code>fff</code>. Zatem jest to <strong>ostatni klaster</strong>.</p>
</div>
<div class="paragraph">
<p>Teraz wystarczy przeczytać klastry w kolejności <code>[4][5]</code>. Klaster [4] zaczyna się od offsetu <code>005600</code> i rzeczywiście 2048 bajtów dalej, tam gdzie spodziewamy się klastra [5] odnajdujemy dalszą część pliku <code>bcdef</code>.</p>
</div>
<div class="paragraph">
<p>Myślę, że już <em>czujesz</em> jak ten system działa. Oczywiście są to tylko proste operacje. Zachęcam do samodzielnego eksperymentowania. Jak system plików będzie zaśmiecony, to zawsze możesz utworzyć nowy. Spróbuj np. dopisać coś do któregoś z plików i sprawdź co się stanie
<em>(spoiler: stara wersja pliku sprzed zmiany zostanie zachowana w pamięci)</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="usuwanie-i-odzyskiwanie-pliku"><a class="anchor" href="#usuwanie-i-odzyskiwanie-pliku"></a>Usuwanie i odzyskiwanie pliku</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Przechodzimy do jednej z najciekawszych rzeczy, czyli co się dzieje gdy usuwamy plik i czy można go odzyskać. Jeśli tak, to jak to zrobić. Tym się teraz zajmiemy.</p>
</div>
<div class="paragraph">
<p>Nadal będziemy pracować na pliku <code>fat.img</code>, który mamy z poprzednich paragrafów. Jeśli Twój obecny po zabawach uległ uszkodzeniu lub zaśmieceniu, to możesz go odtworzyć w ten sposób:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">dd if=/dev/zero of=fat.img bs=1024 count=100
mkfs.msdos fat.img
mkdir fs
sudo mount -t msdos fat.img fs -o umask=000,loop
cd fs
echo "Witaj" &gt; hello
python -c "print('a'*2048 + 'bcdef)" &gt; duzy
sync</pre>
</div>
</div>
<div class="paragraph">
<p>Plik z którym zaczynamy wygląda następująco.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">$ od -Ax -tx1z fat.img
[...]
000200 f8 ff ff 00 f0 ff 05 f0 ff 00 00 00 00 00 00 00  &gt;................&lt;
000210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000400 f8 ff ff 00 f0 ff 05 f0 ff 00 00 00 00 00 00 00  &gt;................&lt;
000410 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000600 48 45 4c 4c 4f 20 20 20 20 20 20 20 00 00 00 00  &gt;HELLO       ....&lt;
000610 00 00 00 00 00 00 fc 6d 07 4f 03 00 06 00 00 00  &gt;.......m.O......&lt;
000620 44 55 5a 59 20 20 20 20 20 20 20 20 00 00 00 00  &gt;DUZY        ....&lt;
000630 00 00 00 00 00 00 dc 84 07 4f 04 00 06 08 00 00  &gt;.........O......&lt;
000640 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
004e00 57 69 74 61 6a 0a 00 00 00 00 00 00 00 00 00 00  &gt;Witaj...........&lt;
004e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
005600 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61  &gt;aaaaaaaaaaaaaaaa&lt;
*
005e00 62 63 64 65 66 0a 00 00 00 00 00 00 00 00 00 00  &gt;bcdef...........&lt;
005e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
019000</pre>
</div>
</div>
<div class="paragraph">
<p>Mamy zatem dwa pliki. Jeden mały i duży. Każdy z nich usuniemy i spróbujemy odzyskać.</p>
</div>
<div class="sect2">
<h3 id="usuwanie-krótkiego-pliku"><a class="anchor" href="#usuwanie-krótkiego-pliku"></a>Usuwanie krótkiego pliku</h3>
<div class="paragraph">
<p>Sama procedura jest dość prosta. Po prostu wchodzimy do kadalogu <code>fs</code> i usuwamy plik <code>hello</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">$ rm hello
$ sync</pre>
</div>
</div>
<div class="paragraph">
<p>No i poszło. Pliku nie ma, ale pytanie co się w praktyce stało? Okazuje się, że w całym pliku <code>fat.img</code> zmieniło się tylko <strong>kilka bajtów</strong>. To wyjaśnia dlaczego usuwanie pliku jest dużo szybsze niż jego kopiowanie. Dane cały czas siedzą na dysku. Poniżej wycinek zrzutu pamięci po usunięciu pliku <code>hello</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">000400 f8 ff ff 00 00 00 05 f0 ff 00 00 00 00 00 00 00  &gt;................&lt;
000410 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000600 e5 45 4c 4c 4f 20 20 20 20 20 20 20 00 00 00 00  &gt;.ELLO       ....&lt;
000610 00 00 00 00 00 00 fc 6d 07 4f 03 00 06 00 00 00  &gt;.......m.O......&lt;
000620 44 55 5a 59 20 20 20 20 20 20 20 20 00 00 00 00  &gt;DUZY        ....&lt;
000630 00 00 00 00 00 00 dc 84 07 4f 04 00 06 08 00 00  &gt;.........O......&lt;
000640 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
004e00 57 69 74 61 6a 0a 00 00 00 00 00 00 00 00 00 00  &gt;Witaj...........&lt;
004e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*</pre>
</div>
</div>
<div class="paragraph">
<p>Co dokładnie zaszło to:
* W tablicy alokacji (offset <code>000400</code> i <code>000200</code>) zwolnił się klaster [3] zajmowany przez plik <code>hello</code>
* Bajt z pierwszą literą w nazwie pliku zmienił wartość na <code>e5</code>.</p>
</div>
<div class="paragraph">
<p>Plik i jego dane nadal znajdują się na dysku. Oczywiście może zostać w każdej chwili nadpisany jeśli zaczniemy tworzyć nowe pliki.</p>
</div>
</div>
<div class="sect2">
<h3 id="odzyskiwanie-krótkiego-pliku"><a class="anchor" href="#odzyskiwanie-krótkiego-pliku"></a>Odzyskiwanie krótkiego pliku</h3>
<div class="paragraph">
<p>Co należy zrobić, aby odzyskać ten plik? W przypadku pliku, który zajmuje tylko jeden klaster jest to proste.
* Odnajdujemy plik w <em>Root Directory Table</em> (lub w folderze gdzie się znajdował)
* Odczytujemy klaster od którego się rozpoczyna ten plik.
* Jeśli klaster jest oznaczony jako zajęty, to już jest za późno. Dane zostały nadpisane przez inny plik.
* Jeśli klaster jest wolny <code>000</code>, to jest szansa, że dane z tego pliku nadal się w nim znajdują.
* Ręcznie oznaczamy klaster jako zajęty <code>fff</code>
* Zmieniamy bajt w nazwie pliku <code>e5</code> na inny znak, np. literę.</p>
</div>
<div class="paragraph">
<p>Aby to wykonać można posłużyć się jakimś Hexedytorem. Jest to oczywiste, gdy dane mamy zapisane w pliku.</p>
</div>
<div class="paragraph">
<p>Co jeśli chcemy to wykonać na urządzeniu typu pendrive? Jest to trochę trudniejsze, ale nadal wykonalne. Wystarczy zrzucić z pendrive&#8217;a pamięć do pliku, podobnie jak robiliśmy tworząc plik <code>fat.img</code> programem <code>dd</code>. Nie musimy nawet zrzucać całości, wystarczy fragment. Po dokonaniu zmian wgrywamy zmodyfikowaną pamięć do urządzenia (w to samo miejsce, z którego ją pobraliśmy).</p>
</div>
<div class="paragraph">
<p>Problemy się zaczynają, gdy chcemy odzyskać duży plik. Taki, który zajmował kilka klastrów.</p>
</div>
</div>
<div class="sect2">
<h3 id="usuwanie-długiego-pliku"><a class="anchor" href="#usuwanie-długiego-pliku"></a>Usuwanie długiego pliku</h3>
<div class="paragraph">
<p>Usuńmy <code>duzy</code> plik i popatrzmy co się stało.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">$ rm duzy
$ sync</pre>
</div>
</div>
<div class="paragraph">
<p>A oto efekt naszych zmian.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">000200 f8 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
000210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000400 f8 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
000410 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
000600 e5 45 4c 4c 4f 20 20 20 20 20 20 20 00 00 00 00  &gt;.ELLO       ....&lt;
000610 00 00 00 00 00 00 fc 6d 07 4f 03 00 06 00 00 00  &gt;.......m.O......&lt;
000620 e5 55 5a 59 20 20 20 20 20 20 20 20 00 00 00 00  &gt;.UZY        ....&lt;
000630 00 00 00 00 00 00 dc 84 07 4f 04 00 06 08 00 00  &gt;.........O......&lt;
000640 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
004e00 57 69 74 61 6a 0a 00 00 00 00 00 00 00 00 00 00  &gt;Witaj...........&lt;
004e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
005600 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61  &gt;aaaaaaaaaaaaaaaa&lt;
*
005e00 62 63 64 65 66 0a 00 00 00 00 00 00 00 00 00 00  &gt;bcdef...........&lt;
005e10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
*
019000</pre>
</div>
</div>
<div class="paragraph">
<p>Tablica alokacji jest pusta. Wszystkie klastry zajmowane przez plik zostały zwolnione, a pierwszy bajt w nazwie pliku <code>duzy</code> ma wartość <code>e5</code>. Żadnych zaskoczeń.</p>
</div>
</div>
<div class="sect2">
<h3 id="odzyskiwanie-długiego-pliku"><a class="anchor" href="#odzyskiwanie-długiego-pliku"></a>Odzyskiwanie długiego pliku</h3>
<div class="paragraph">
<p>Teraz mamy problem i to poważny. Co prawda z <em>Root Directory Table</em> nadal możemy odczytać pierwszy sektor zajmowany przez plik, ale gdy udamy się do tablicy alokacji pod wskazany sektor, to okaże się, że jest on wolny <code>000</code>. To świetne wieści, ale pozostaje pytanie, <strong>który klaster jest tym następny</strong>?</p>
</div>
<div class="paragraph">
<p>Po rozmiarze pliku możemy obliczyć ile klastrów będzie on zajmować. Musimy je "tylko" odnaleźć i to jeszcze <strong>w dobrej kolejności</strong>.</p>
</div>
<div class="paragraph">
<p>Niestety nie ma tutaj błyskotliwego rozwiązania tego problemu. Zgadywanie zwykle nie wchodzi w grę. Jest jednak wiele metod, które pozwolą zwiększyć szansę na odzyskanie takiego pliku. Poniżej kilka z nich:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Defragmentacja dysku często sprawia, że wszystkie klastry pliku znajdują się obok siebie jeden za drugim. Z drugiej strony wykonanie defragmentacji <strong>po</strong> usunięciu pliku może "zapchać dziury po usuniętych plikach", a więc nadpisać ich dane.</p>
</li>
<li>
<p>Stosowanie różnego rodzaju heurystyk.</p>
</li>
<li>
<p>Rozpoznawanie formatu pliku po pierwszym klastrze. Wiemy wtedy jakiej następnej części się spodziewać, np. gdy odzyskujemy plik wideo, to czasami wraz z zakodowanym obrazem znajdują się timestamp&#8217;y określające moment w filmie.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Jest zapewne dużo więcej sposobów. Wiele z nich to tajemnice firm produkujących oprogramowanie do odzyskiwania danych z dysków. Jeśli próbowałeś kiedyś któregoś z tych "darmowych" narzędzi do odzyskiwania plików po ich usunięciu, to wiesz już teraz dlaczego one z taką łatwością wypisywały usunięte pliki z nazwami, a za ich odzyskanie trzeba było już zapłacić. Odnalezienie usuniętych plików jest po prostu banalnie proste.</p>
</div>
<div class="paragraph">
<p>Mówię tutaj oczywiście o formacie FAT. Struktury plików zapisanych w NTFS czy ext są zupełnie inne i bardziej skomplikowane. Nawet w samym FAT32 jest już sporo zmian w stosunku do FAT12, który przedstawiałem.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="podsumowanie"><a class="anchor" href="#podsumowanie"></a>Podsumowanie</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jeśli nigdy wcześniej nie miałeś, czytelniku, okazji pobawić się z systemem plików, to mam nadzieję, że wykonane tutaj eksperymenty i zaprezentowane przykłady sporo nauczyły. To dopiero wierzchołek góry lodowej. O samym FAT12 możnaby zrobić jeszcze 10 podobnej długości artykułów. Zamiast to robić, lepszym pomysłem jest zapoznanie się z nowszymi systemami plików. Porównać omówiony tutaj FAT12 z używanym jeszcze powszechnie na pendrive&#8217;ach FAT32.</p>
</div>
<div class="paragraph">
<p>Do czego może się przydać taka wiedza? Mało kto ręcznie grzebie w bajtach, więc wiedza o działaniu systemu plików przyda się do napisania oprogramowania, który na takim systemie operuje. Poza tym daje ogólne <strong>zrozumienie wielu procesów, które zachodzą w komputerze</strong>. Mimo, że o tym nie wspomniałem, to po przeczytaniu tego artykułu powinieneś już rozumieć dlaczego w Windowsie każdy plik ma <em>rozmiar</em> i <em>rozmiar na dysku</em>. To tak jak nasz krótki plik, który miał rozmiar 6 bajtów, a na dysku zajmował jeden klaster, a więc 2 kB. To spore marnotrawstwo pamięci i współczesne systemy plików lepiej sobie z tym radzą.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Dygresja o NTFS</div>
<div class="paragraph">
<p>W NTFS na Windowsie jest trochę inaczej. Zrób eksperyment. Utwórz w Windowsie pusty plik i sprawdź jego <em>rozmiar</em> i <em>rozmiar na dysku</em>. Oba będą wynosić 0 B. Dodaj literkę <code>a</code> do pliku, zapisz i sprawdź. Ile wynosi rozmiar? 1 B. Rozmiar na dysku nadal 0 B. NTFS działa trochę inaczej i jest w stanie dane krótkich plików zmieścić wraz z nazwą w jednym rekordzie bez zajmowania całego klastra. Po zwiększeniu pliku do 1 kB, rozmiar na dysku wyniesie 4 kB (w moim przypadku). Po zmniejszeniu pliku do 1 B, rozmiar na dysku pozostaje 4 kB. Widać, że ten system plików jest inteligentniejszy.</p>
</div>
</div>
</div>
</div>
</div>

    </article>

    
    
    

    <h2>Zobacz jeszcze </h2>
    <ul>
        
        
        <li><a href="/wpis/jak-powstal-ten-blog/">Jak powstał ten blog</a></li>
        
        
        
        <li><a href="/wpis/processing-do-nauki-programowania/">Processing do nauki programowania</a></li>
        
        
        
        
        
        
    </ul>

</main>

<!-- Stopka -->
<div class="w3-light-gray">
    <div class="w3-row-padding w3-auto w3-margin-top w3-stretch">

        <div class="w3-third w3-padding-large">
            <h3 class="w3-center">O Autorze</h3>
            <p class="w3-justify">Jestm studentem informatyki z Wrocławia. Brak czasu to moje drugie imię. Jeszcze będąc małym glutem wiedziałem, że będę żył ze stukania w przyciski klawiatury. W wolnej chwili uzupełniam tę stronę o nowe wpisy.</p>
        </div>
    
        <div class="w3-third w3-padding-large">
            <h3 class="w3-center">Nieśmiertelny cytat</h3>
            <p class="w3-center">„Największą przeszkodą, która w znaczący sposób spowalnia sprawdzanie pisanych przez państwa egzaminów jest śmiech.”</p>
            <p class="w3-right">~ M.G.</p>
        </div>
    
        <div class="w3-third w3-padding-large w3-center">
            <h3 class="w3-center">Szybka nawigacja</h3>
            <ul class="w3-left-align" style="display: inline-block">
                <li><a href="https://github.com/KyrietS" class="w3-hover-opacity">Znajdź mnie na GitHub</a></li>
                <li><a href="/projekty/" class="w3-hover-opacity">Zobacz moje projekty</a></li>
                <li><a href="/kontakt/" class="w3-hover-opacity">Formularz kontaktowy</a></li>
                <li><a href="/sitemap.xml" class="w3-hover-opacity">Mapa strony</a></li>
            </ul>
        </div>
    </div>
</div>

<script src="/js/main.js"></script>

<!-- Mathjax w wersji 3.x.x -->
<script>
    MathJax = {
        loader: {load: ['input/asciimath']},
        tex: {
            inlineMath: [["\\(", "\\)"]],
            displayMath: [["\\[", "\\]"]],
            processEscapes: false,      // use \$ to produce a literal dollar sign
        },
        asciimath: {
            delimiters: [["\\$", "\\$"]]
        },
        chtml: {
            scale: 1,
            matchFontHeight: true
        },
        options: {
            ignoreHtmlClass: "nostem|noasciimath"
        },
        // Tymczasowy fix dla wersji v3.0.1 (https://github.com/mathjax/MathJax/issues/2327)
        startup: {
            pageReady() {
                const options = MathJax.startup.document.options;
                const BaseMathItem = options.MathItem;
                options.MathItem = class FixedMathItem extends BaseMathItem {
                    assistiveMml(document) {
                        if (this.display !== null) super.assistiveMml(document);
                    }
                };
                return MathJax.startup.defaultPageReady();
            }
        }
    };
</script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> 

<script src="/js/search.js"></script>
<script>
SimpleJekyllSearch({
  searchInput: document.getElementById('dropdown-search-input'),
  resultsContainer: document.getElementById('dropdown-search-results'),
  limit: 4,
  success: () => {},
  json: [{"title":"Processing do nauki programowania","url":"/wpis/processing-do-nauki-programowania/"},{"title":"Jak jest zbudowany system plików FAT","url":"/wpis/jak-jest-zbudowany-fat/"},{"title":"Jak powstał ten blog","url":"/wpis/jak-powstal-ten-blog/"},{"title":"Test kolorowania składni","url":"/wpis/test-kolorowania-skladni/"},{"title":"Pokaz możliwości Asciidoc&#8217;a na tej stronie","url":"/wpis/asciidoc-demo/"}],
  noResultsText: '',
  searchResultTemplate: `<a href="{url}" class="w3-bar-item w3-button">{title}</a>`
});
</script>

</body>
</html>